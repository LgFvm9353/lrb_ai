# 闭包
closure 是js 的重要语法特性，能访问 自由变量 的函数就叫闭包
当一个内部函数访问了它所在的外部函数作用域中的变量，即使外部函数已经执行完毕，
这些变量仍然停留在内存中，供内部函数调用，这种机制就是闭包

你不知道的JavaScript 闭包 = 函数 + 词法作用域 （本质）

形成条件: 函数嵌套 + 内部函数引用了外部函数的变量 + 函数逸出
    立即执行函数、块级作用域 + 定时器

- 底层原理
  核心是词法作用域 ，函数在定义时就确定了它的词法作用域，而不是在调用时确定

  作用域链（scope chain） 内部函数在查找变量时，会沿着作用域链向上查找，直到找到全局作用域
  变量持久化：由于闭包函数依然引用自由变量，JS 引擎的GC (Garbage Collection 垃圾回收机制) 认为这些外部变量还在用，所以不会销毁，导致变量值持久存在

- 模型图
  
   [Global Scope]
         ^
         |
   [Outer Function Scope]
         ^ 
         |
   [Inner Function Scope]
    
- 业务场景
  - 数据私有化
     封装类或函数的复杂性
  - 防抖/节流
  - 循环绑定事件
    ```js
    for(var i = 0; i < 5; i++){
        setTimeout(()=>{
            console.log(i)
        })
    }
    var -> let  闭包
    立即执行函数
    ```
  - 缓存记忆优化 
    ```js
     function memoize(fn)
     {
       const cache = {}
       return function(key)
       {
         if(cache[key]){
            return cache[key]
         }
         cache[key] = fn(key)
         return cache[key]
       }
     }
    ```
  - 柯理化函数
    一个接收多个参数的函数，转换一系列只接受一个参数的函数链
  - 偏函数
    固定函数的某些参数，返回一个新函数，新函数接收剩余参数
    ```js
    function partial(fn, ...args) {
        return function (...newArgs) {
            return fn(...args, ...newArgs)
        }
    }
    ```

## 总结

闭包是函数与外部词法作用域的组合，它让函数在外部作用域执行完后依然能访问内部变量，本质是作用域链导致变量持久化，在工程中常用于数据私有化、防抖、节流等

我在项目中经常用闭包减少全局变量污染，但也注意可能带来内存泄露，不需要时需要手动释放

## setTimeout 里的回调函数是闭包吗？
从定义上说，setTimeout 的回调一般会形成闭包，因为它在创建的时候捕获了外层函数的变量，即使外层函数执行结束，变量依然可以访问

但严格来说，setTimeout 的回调函数本身不是闭包，因为闭包的本质是函数+词法环境的绑定。是否是闭包，取决于回调是否调用自由变量

比如在循环定时器时，用let 申明块级作用域或IIFE 闭包定时器回调，是闭包

