# React Fiber机制

- 为很么要引入fiber 架构
   在react15 之前，其“协调器”（负责比较新旧虚拟 DOM 树、找出需要更新的部分）使用的是递归、同步、不可中断的方式：
   递归：协调器会递归遍历虚拟 DOM 树，比较每个节点的差异。
   同步：协调器在遍历过程中，会立即执行 DOM 操作，将差异应用到真实 DOM 上。
   不可中断：一旦协调器开始工作，就不能被中断，必须完成所有的比较和 DOM 操作。
   这就导致了这么一个现象，一旦开始更新，就必须完成整个组件树的diff和更新，不能暂停。如果组件树很大的话，这个过程会阻塞主线程，浏览器无法响应用户的交互操作，导致页面卡顿。

- 组件比较多，组件树（树状组件）的深度比较深
   每个组件都需要经历 JSX模板的编译、VDOM 的创建、响应式的生命、生命周期、挂载等

   怎么办？核心问题是什么？
   react 渲染是同步代码，更加重要的没有机会做
   打断一下，让浏览器响应用户更优先得先做一下，到时候再回来接着执行


- fiber机制是react 16 引入的重写核心算法，实现了可中断渲染

  - 学过什么 api类 事fiber
     可打断可持续
     requestAnimationFrame
     requestIdleCallback

- requestAnimationFrame
  是浏览器提供的用于在下一次重绘之前执行动画代码的API，它能确保动画流畅运行并节省资源。 1s执行60次

  - 工作原理
    1. 浏览器会在每次重绘之前调用 requestAnimationFrame 注册的回调函数。
    2. 回调函数会接收一个时间戳参数，代表当前的时间点。
    3. 在回调函数中，你可以进行动画的计算和更新操作。
    4. 浏览器会根据动画的计算结果，在下一次重绘之前调用回调函数。
    5. 这个过程会一直持续下去，直到动画完成或被取消。

- requestIdleCallback
  - React 组件渲染 低优先级任务
      不能往死里干，需要被中断
  - 更高优先级的任务是 用户的交互

  - react 组件树 渲染任务
    在一个时间切片里能执行
    这个时间长度用requestIdleCallback 来描述的
    一直去问还有多少可执行时间

## 总结一下
- react 组件多，组件树深度，渲染耗时，复杂
- 使用requestIdleCallback 中断渲染
- 优先响应界面交互和核心任务
- 当再次idle 后，继续执行渲染任务
- requestIdleCallback 时间不定，16.67ms（刷帧） - 优先任务的耗时 = 本次执行时间
- 没有fiber react组件一多，就会卡顿，fiber 解决性能问题，主要通过中断渲染，保障用户交互交互，解决大型应用阻塞主线程的问题。
- fiber 节点，react 渲染的工作单元


## Render 分成两个阶段
- 渲染阶段  构建新的虚拟dom树，diff patches []
- 提交阶段  应用patches 到真实dom 上


## diff算法 
- 同层级比较  不然时间复杂度是O(n^3)
  - ABCDE EABCD 
  dom 开销比较大
  diff 算法除了考虑本身的时间复杂度之外，还要考虑一个因素：dom 操作的次数 
  移动操作比新增/删除操作要少，所以diff 算法会优先考虑移动操作 
  insertBefore 
  - 新老节点的type 相同，比较props
  - 新老节点的type 不同，直接替换

- 简单DIFF 算法
ABCD -> DCAB
  1. A 不需要移动
  2. B 不需要移动
  3. C 移动到最前面
  4. D 移动到最前面
  
  多节点diff 节点是为了尽量复用节点，通过移动代替新增节点